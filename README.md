# 자바스크립트 기본기 공부

## 자바스크립트의 특징

자바스크립트는 인터프리터, 동적 타입, 프로토타입 기반 객체지향 언어이다. 웹에 기본적으로 내장되어 있어서 html, css와 함께 유일하게 웹에서 사용할 수 있는 언어다. 또한 nodejs를 이용해 서버나 cli 프로그램을 만들수도 있다.

### 인터프리터 언어 vs 컴파일러 언어

인터프리터 언어는 한 줄마다 기계어로 번역해서 속도가 느리고 수정이 편하다.
컴파일러 언어는 컴파일 하는데 시간이 걸리지만 속도가 빠르다.
자바스크립트는 인터프리터 언어지만 두 가지 장점을 결합해 속도가 빠르다.

### 동적 타입 언어 vs 정적 타입 언어

정적 타입 언어는 변수를 선언할 때 데이터 타입을 미리 지정한다.
동적 타입 언어는 데이터 타입을 미리 지정하지 않는다. 그래서 편하지만 복잡한 프로그래밍에서는 변수를 추적하기 어렵다. 그래서 자바스크립트에서는 스코프를 좁게 만들고 모듈을 사용하고 전역 변수 사용을 최소화하고 상수를 만든다. 요즘에는 타입 지정이 필요하다고 생각해서 타입스크립트를 사용하는 추세다.

### 웹 vs nodejs

자바스크립트는 기본적으로 ECMAScript를 따른다. 그리고 웹에서는 client-side API를 nodejs에서는 nodejs-host API를 가지고 있다. 참고로 nodejs는 Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다. 서버가 아니다!! 서버로 많이 이용될 뿐이다.

## 원시값 vs 객체

원시값은 immutable이고 객체는 mutable이다. 즉 원시값은 실제 값이 저장되고 객체는 참조 값이 저장되는 것이다. 그래서 원시값을 갖는 변수를 다른 변수에 할당하면 원시값이 복사가 되는데 객체를 갖는 변수를 다른 변수에 할당하면 참조값이 복사가 된다.

ex)

```
var a=10;
var b=a;
b=5;
console.log(a);  // => 10
var obj = { a: 10, b: 20};
var copy = obj;
delete copy.a;
console.log(obj);  // => {b: 20}
```

## 스코프

- 정의 : 식별자가 유효한 범위(전역, 지역)

스코프 체인 : 스코프가 계층적으로 연결된 것

스코프는 함수의 중첩에 의해 계층적 구조를 갖는다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 선언된 변수를 검색한다.

동적 스코프 : 함수를 어디서 호출했는지에 따라 함수의 스코프를 결정

렉시컬 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정(js)

## 전역변수의 문제점

1. 암묵적 결합 : 전역변수를 사용하고 다음 스코프에서 같은 변수명을 사용할 때 원하지 않는 결합을 하는 경우가 존재
2. 긴 생명주기 : 전역변수면 변수가 계속 존재하기 때문에 메모리 측면에서 낭비
3. 스코프 체인 상에서 종점에 존재 : 여러 스코프를 통과해야 하기 때문에 검색 속도가 느림
4. 네임 스페이스의 오염 : 파일이 분리되어 있다고 해도 자바스크립트는 하나의 전역 스코프를 공유

과거에는 전역변수의 사용을 막기 위해서 즉시실행함수를 많이 사용했다. 요즘에는 모듈을 사용한다. 그리고 전역 변수가 필요하다면 옵저버블 패턴을 이용해 가져올 수 있다. 이를 이용한 대표적인 라이브러리가 리덕스다.

## var, let, const

과거에 자바스크립트는 변수를 선언할 방법이 var만 존재했다. 가장 큰 var의 문제점은 함수 레벨 스코프라는 것이다. 그리고 다른 몇 가지의 문제점도 존재한다.

1. 함수 레벨 스코프

var는 함수 레벨 스코프다. 즉, 함수에서 선언한 var는 지역변수로 저장되지만 다른 곳에서 선언한 var는 전역 변수로 저장된다. 예시를 살펴보자

함수가 아닌 곳에서 선언된 var

```
for(var i=0;i<10;i++){
    console.log(i);
}
0
1
2
3
4
5
6
7
8
9
console.log(i);
10
```

함수에서 선언된 var

```
function hi(){
    for(var i=0;i<10;i++){
        console.log(i);
    }
}
hi()
0
1
2
3
4
5
6
7
8
9
console.log(i);
Uncaught ReferenceError: i is not defined
    at <anonymous>:1:1
```

이는 자바스크립트를 사용하는 개발자들을 혼란시킨다. 위는 매우 간단한 예제이지만 코드가 복잡해질 수록 더욱 더 혼란스러워진다.

let과 const는 블록 레벨 스코프이다. 즉, 모든 블록에서 선언된 변수가 지역변수로 저장된다.

함수가 아닌 곳에서 선언된 let

```
for(var i=0;i<10;i++){
    console.log(i);
}
0
1
2
3
4
5
6
7
8
9
console.log(i);
Uncaught ReferenceError: i is not defined
    at <anonymous>:1:13
```

2. 호이스팅

자바스크립트는 코드 평가 과정을 거쳐서 실행된다. 이 과정중에 변수가 호이스팅된다. 즉 뒤에서 선언한 변수가 앞에서 참조할 수 있게 되는 것이다.

var에서 호이스팅 예시

```
console.log(i); // undefined
var i=1;
console.log(i); // 1
```

보통 다른 언어에서는(다른 언어를 잘 몰라서 틀릴지도 모른다) 변수를 맨 위에 선언한다. 자바스크립트에서는 이렇게 중간에 선언을 해도 괜찮다. 그런데 우리는 i가 선언되고 할당된 후에 로그가 찍히는 것을 원한다. 그런데 선언만 되고 할당이 되지 않았다.(더 정확히는 undefined가 할당되고 1로 재할당 되기 이전에 undefined 로그가 찍힌것이다.) 이런 경우에는 에러를 발생시키는 것이 더 좋다.

let(const)에서 호이스팅 예시

```
console.log(i);
ReferenceError: i is not defined
let i=1;
console.log(i);
```

마치 호이스팅이 발생하지 않는 것 같다. 하지만 호이스팅은 발생한다. var와 다르게 동작할 뿐이다. let, const로 변수를 할당하면 선언은 되지만 초기화(undefined 할당)가 되지 않는다. 변수의 선언과 초기화 사이에 일시적으로 변수 값을 참조할 수 없는 구간을 TDZ(Temporal Dead Zone)라고 한다.

TDZ 확인 예시

```
let a=10;
console.log(a);
(function(){
    console.log(a);
    let a=1;
    console.log(a);
})()
Uncaught ReferenceError: Cannot access 'a' before initialization
```

3. 중복 선언

var는 중복선언이 가능하다. 이는 개발자에게 혼란을 준다. 그래서 let, const는 중복 선언이 되지 않는다. 물론 다른 스코프에서는 중복 선언이 가능하다.

let 중복 선언 에러 예시

```
let i=1;
let i=100;
SyntaxError: Identifier 'i' has already been declared
```

4. 재할당

var는 중복 선언 뿐만 아니라 재할당도 가능하다. 이것도 막는 것이 좋아 보인다. 그런데 재할당이 필요한 경우가 존재한다. 가장 대표적인 for문만 하더라도 재할당이 필요하다. 이것이 let과 const 두 가지 변수 선언방법이 추가된 이유이다. 재할당이 필요없는 경우는 const, 재할당이 필요한 경우는 let으로 선언하는 것이다. 즉 기본적으로 모든 변수는 const로 할당하고 필요한 경우만 let으로 변경하자.

5. 전역 객체 프로퍼티

함수 레벨 스코프를 설명하면서 나온 얘기긴 한데 조금 더 세부적으로 얘기하겠다. 함수 스코프를 제외한 나머지 스코프에서 선언된 var는 모두 전역 변수이다. 즉 window 객체 안에 존재한다. 위에서 설명했듯이 무분별한 전역 변수 생성은 좋지 않다.

```
let a=1; undefined
window.a undefined
```

## 콜백함수 vs 고차함수

### 콜백함수

- 정의 : 다른 함수에 매개 변수(argument)로 넘겨준 함수

즉 함수를 호출할 때 인자에 함수를 넣는 다면 그 함수가 바로 콜백함수다. 이게 가능한 이유는 자바스크립트는 함수는 일급 객체이기 때문이다.
자바스크립트에서 콜백함수는 많이 사용되는 패턴이다. 콜백함수를 사용하는 여러가지 이유가 있겠지만 가장 큰 이유는 비동기 처리 방식의 문제점을 해결하기 때문이다.
ajax 통신을 생각해보자. 페이스북에 접속하면 로그인 정보를 확인하고 그에 따른 처리를 한다. 로그인 정보를 확인할 때 비동기 통신이 이용된다. 그런데 우리는 데이터를 받아오고 그 후에 처리를 해야한다. 즉 비동기를 동기적으로 만들필요가 있다. 이런 경우에 콜백함수를 이용한다. 데이터를 받아오고 그 후에 콜백함수를 실행하는 것이다. 그런데 이 콜백함수를 사용하다보면 콜백지옥이라는 문제에 빠지게 된다. 이를 개선하기 위해 promise가 나왔고 그 promise를 기반으로 발전시킨 기술이 async await다.

### 고차함수

- 정의 : 함수를 인자(argument)로 전달받거나 함수를 결과로 리턴하는 함수

배열에서 흔하게 사용하는 sort, forEach, map, filter 등이 고차함수의 대표적인 예시다. 고차함수와 비슷한 개념으로 리액트에서 고차 컴포넌트를 사용하기도 한다.

## this

자바스크립트에서 this는 함수를 호출하는 방법에 의해 결정된다.

1. 일반함수 : this는 전역객체(웹이라면 window)를 가리킨다.

```
function hi(){
    console.log(this);
}
hi();
// Window {0: Window, window: Window, self: Window, document: document, name: '', location: Location, …}
```

2. 메서드 : this는 호출한 객체를 가리킨다.

```
const obj={
    a:10,
    b(){
        console.log(this);
    },
    c:function(){
        console.log(this);
    }
}

obj.b()
// {a: 10, b: ƒ, c: ƒ}

obj.c()
// {a: 10, b: ƒ, c: ƒ}
```

3. 생성자 함수 : 생성자 함수가 생성한 인스턴스를 가리킨다.

4. 화살표 함수 : 외부 스코프의 this를 가리킨다.

```
function Animal(name){
    this.name=name;
    console.log(this);
}

const dog=new Animal('dog')
// Animal {name: 'dog'}
```

5. apply, call, bind : 인수에 의해 결정

## 화살표함수

## call, apply, bind

## 실행 컨텍스트

## 클로저

## 이벤트(버블링, 캡쳐링, 위임)

## 자바스크립트 엔진과 이벤트루프

## AJAX와 XMLHTTPRequest

## REST API

## 프로미스

## async await

## 제너레이터

## 프로토타입

## 객체지향
